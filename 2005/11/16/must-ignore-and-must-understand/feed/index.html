<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Must-Ignore and Must-Understand	</title>
	<atom:link href="https://quoderat.megginson.com/2005/11/16/must-ignore-and-must-understand/feed/" rel="self" type="application/rss+xml" />
	<link>https://quoderat.megginson.com/2005/11/16/must-ignore-and-must-understand/</link>
	<description>Open information and technology.</description>
	<lastBuildDate>Tue, 07 Feb 2006 11:54:02 +0000</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
	<item>
		<title>
		By: THOUSANDMINDS &#187; Making Mistakes with XML		</title>
		<link>https://quoderat.megginson.com/2005/11/16/must-ignore-and-must-understand/#comment-345</link>

		<dc:creator><![CDATA[THOUSANDMINDS &#187; Making Mistakes with XML]]></dc:creator>
		<pubDate>Tue, 07 Feb 2006 11:54:02 +0000</pubDate>
		<guid isPermaLink="false">http://www.megginson.com/blogs/quoderat/?p=70#comment-345</guid>

					<description><![CDATA[[...] One approach is to include attributes such as version and compatible-with in your elements. The values of these attributes can indicate what version of your language an element comes from, and what versions an element is compatible with. This affords applications an opportunity to take some more intelligent action based on what they receive and what they generate. Another approach is to leverage the &#8220;must-ignore/must-understand&#8221; design pattern (although it suffers some shortcomings). [...]]]></description>
			<content:encoded><![CDATA[<p>[&#8230;] One approach is to include attributes such as version and compatible-with in your elements. The values of these attributes can indicate what version of your language an element comes from, and what versions an element is compatible with. This affords applications an opportunity to take some more intelligent action based on what they receive and what they generate. Another approach is to leverage the &#8220;must-ignore/must-understand&#8221; design pattern (although it suffers some shortcomings). [&#8230;]</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Rasmus Kaj		</title>
		<link>https://quoderat.megginson.com/2005/11/16/must-ignore-and-must-understand/#comment-344</link>

		<dc:creator><![CDATA[Rasmus Kaj]]></dc:creator>
		<pubDate>Wed, 30 Nov 2005 11:18:07 +0000</pubDate>
		<guid isPermaLink="false">http://www.megginson.com/blogs/quoderat/?p=70#comment-344</guid>

					<description><![CDATA[Actually, there is two different way to &quot;ignore&quot; an element as well, to complicate matters further ...  Either you can ignore the element and the contents of that element (as you do in your example), or you can ignore the element and treat the child elements as beloning to the parent element (like in html).

Or actually, there&#039;s a third possibility; just treat the element as an element with no semantics (differs from  method #2 in how selectors work on child elements to the unknown element).]]></description>
			<content:encoded><![CDATA[<p>Actually, there is two different way to &#8220;ignore&#8221; an element as well, to complicate matters further &#8230;  Either you can ignore the element and the contents of that element (as you do in your example), or you can ignore the element and treat the child elements as beloning to the parent element (like in html).</p>
<p>Or actually, there&#8217;s a third possibility; just treat the element as an element with no semantics (differs from  method #2 in how selectors work on child elements to the unknown element).</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Bill de hOra		</title>
		<link>https://quoderat.megginson.com/2005/11/16/must-ignore-and-must-understand/#comment-343</link>

		<dc:creator><![CDATA[Bill de hOra]]></dc:creator>
		<pubDate>Mon, 21 Nov 2005 00:12:30 +0000</pubDate>
		<guid isPermaLink="false">http://www.megginson.com/blogs/quoderat/?p=70#comment-343</guid>

					<description><![CDATA[mU/mI are a way to tunnel evaluators through XML. It&#039;s like obfuscated code-sharing :)

Atom is different insofar as the best thing to do with it is squint your eyes and try and see the serialization of a dictionary. It&#039;s by-design additive, so it makes no sense (imo) to hobble it with mumi directives - indeed it would be nuts - imagine throwing a runtime exception because a hashmap has keys you can&#039;t dispatch on.  Atom drags the XML crowd about halfway to RDF.]]></description>
			<content:encoded><![CDATA[<p>mU/mI are a way to tunnel evaluators through XML. It&#8217;s like obfuscated code-sharing ðŸ™‚</p>
<p>Atom is different insofar as the best thing to do with it is squint your eyes and try and see the serialization of a dictionary. It&#8217;s by-design additive, so it makes no sense (imo) to hobble it with mumi directives &#8211; indeed it would be nuts &#8211; imagine throwing a runtime exception because a hashmap has keys you can&#8217;t dispatch on.  Atom drags the XML crowd about halfway to RDF.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: John Cowan		</title>
		<link>https://quoderat.megginson.com/2005/11/16/must-ignore-and-must-understand/#comment-342</link>

		<dc:creator><![CDATA[John Cowan]]></dc:creator>
		<pubDate>Thu, 17 Nov 2005 18:02:31 +0000</pubDate>
		<guid isPermaLink="false">http://www.megginson.com/blogs/quoderat/?p=70#comment-342</guid>

					<description><![CDATA[Absolutely.]]></description>
			<content:encoded><![CDATA[<p>Absolutely.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: david		</title>
		<link>https://quoderat.megginson.com/2005/11/16/must-ignore-and-must-understand/#comment-341</link>

		<dc:creator><![CDATA[david]]></dc:creator>
		<pubDate>Thu, 17 Nov 2005 13:11:39 +0000</pubDate>
		<guid isPermaLink="false">http://www.megginson.com/blogs/quoderat/?p=70#comment-341</guid>

					<description><![CDATA[Thanks for the comment, John.  I agree with what you write, but only in reference to a specific processing context.  The elements that an application &lt;em&gt;must understand&lt;/em&gt; to complete a business transaction are not necessarily the same elements that an application &lt;em&gt;must understand&lt;/em&gt; to index a document for search, or to format it as PDF.]]></description>
			<content:encoded><![CDATA[<p>Thanks for the comment, John.  I agree with what you write, but only in reference to a specific processing context.  The elements that an application <em>must understand</em> to complete a business transaction are not necessarily the same elements that an application <em>must understand</em> to index a document for search, or to format it as PDF.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: John Cowan		</title>
		<link>https://quoderat.megginson.com/2005/11/16/must-ignore-and-must-understand/#comment-340</link>

		<dc:creator><![CDATA[John Cowan]]></dc:creator>
		<pubDate>Thu, 17 Nov 2005 12:30:53 +0000</pubDate>
		<guid isPermaLink="false">http://www.megginson.com/blogs/quoderat/?p=70#comment-340</guid>

					<description><![CDATA[It seems to me that the true meaning of &quot;must-understand&quot; conventions is this:  if you get something that is implicitly or explicitly marked &quot;must-understand&quot;, then if you don&#039;t understand it, you don&#039;t understand anything else either.  The fact that Atom has no &quot;must-understand&quot;, and treats everything not documented as belonging in an Atom document (even things in the Atom namespace) as &quot;must-ignore&quot; means that no new Atom element can change the intended semantics of an existing Atom element.  (Tim says this is okay with him/them.)

But if adding a new element might change the purpose of old elements, then &quot;must-understand&quot; is a sensible notion:  RELAX NG and XML Catalogs are &quot;must-ignore&quot; for elements and attributes outside the RNG namespace, but &quot;must-understand&quot; for things in the namespace: if you see a (currently unknown) element, you are probably trying to process a new version, and all bets are off as far as the interpretation of existing elements.  (Just my opinion, not attributable to any OASIS TCs.)]]></description>
			<content:encoded><![CDATA[<p>It seems to me that the true meaning of &#8220;must-understand&#8221; conventions is this:  if you get something that is implicitly or explicitly marked &#8220;must-understand&#8221;, then if you don&#8217;t understand it, you don&#8217;t understand anything else either.  The fact that Atom has no &#8220;must-understand&#8221;, and treats everything not documented as belonging in an Atom document (even things in the Atom namespace) as &#8220;must-ignore&#8221; means that no new Atom element can change the intended semantics of an existing Atom element.  (Tim says this is okay with him/them.)</p>
<p>But if adding a new element might change the purpose of old elements, then &#8220;must-understand&#8221; is a sensible notion:  RELAX NG and XML Catalogs are &#8220;must-ignore&#8221; for elements and attributes outside the RNG namespace, but &#8220;must-understand&#8221; for things in the namespace: if you see a (currently unknown) element, you are probably trying to process a new version, and all bets are off as far as the interpretation of existing elements.  (Just my opinion, not attributable to any OASIS TCs.)</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Uche		</title>
		<link>https://quoderat.megginson.com/2005/11/16/must-ignore-and-must-understand/#comment-339</link>

		<dc:creator><![CDATA[Uche]]></dc:creator>
		<pubDate>Thu, 17 Nov 2005 05:54:34 +0000</pubDate>
		<guid isPermaLink="false">http://www.megginson.com/blogs/quoderat/?p=70#comment-339</guid>

					<description><![CDATA[If I understand you rightly, Walter Perry has been saying this sort of thing for years, and I think it&#039;s a very important insight for making sure that XML is not too strongly tied to far more ephemeral application models.  Schematic and modeling systems should basically talk about what they know to talk about, and not try to philosophize about every possible hypothetical characteristic of data in the system.  It&#039;s up to the application layer to use the right modeling tools to satisfy the *local* business semantics.]]></description>
			<content:encoded><![CDATA[<p>If I understand you rightly, Walter Perry has been saying this sort of thing for years, and I think it&#8217;s a very important insight for making sure that XML is not too strongly tied to far more ephemeral application models.  Schematic and modeling systems should basically talk about what they know to talk about, and not try to philosophize about every possible hypothetical characteristic of data in the system.  It&#8217;s up to the application layer to use the right modeling tools to satisfy the *local* business semantics.</p>
]]></content:encoded>
		
			</item>
	</channel>
</rss>
