<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: SQL and simple polymorphism	</title>
	<atom:link href="https://quoderat.megginson.com/2010/09/25/sql-and-simple-polymorphism/feed/" rel="self" type="application/rss+xml" />
	<link>https://quoderat.megginson.com/2010/09/25/sql-and-simple-polymorphism/</link>
	<description>Open information and technology.</description>
	<lastBuildDate>Sun, 11 Mar 2018 02:11:58 +0000</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
	<item>
		<title>
		By: David Megginson		</title>
		<link>https://quoderat.megginson.com/2010/09/25/sql-and-simple-polymorphism/#comment-17132</link>

		<dc:creator><![CDATA[David Megginson]]></dc:creator>
		<pubDate>Sun, 11 Mar 2018 03:11:58 +0000</pubDate>
		<guid isPermaLink="false">http://quoderat.megginson.com/?p=403#comment-17132</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://quoderat.megginson.com/2010/09/25/sql-and-simple-polymorphism/#comment-17130&quot;&gt;Ribaldos&lt;/a&gt;.

Wouldn&#039;t that just be a different implementation strategy for the same concept?]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://quoderat.megginson.com/2010/09/25/sql-and-simple-polymorphism/#comment-17130">Ribaldos</a>.</p>
<p>Wouldn&#8217;t that just be a different implementation strategy for the same concept?</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Ribaldos		</title>
		<link>https://quoderat.megginson.com/2010/09/25/sql-and-simple-polymorphism/#comment-17130</link>

		<dc:creator><![CDATA[Ribaldos]]></dc:creator>
		<pubDate>Sat, 10 Mar 2018 15:32:50 +0000</pubDate>
		<guid isPermaLink="false">http://quoderat.megginson.com/?p=403#comment-17130</guid>

					<description><![CDATA[This is no polymorphism. It would be when &quot;Locations&quot; had a (virtual) column which is dispatched to different implementations (e.g. retrieving columns from the child table).]]></description>
			<content:encoded><![CDATA[<p>This is no polymorphism. It would be when &#8220;Locations&#8221; had a (virtual) column which is dispatched to different implementations (e.g. retrieving columns from the child table).</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Chris Hennick		</title>
		<link>https://quoderat.megginson.com/2010/09/25/sql-and-simple-polymorphism/#comment-9012</link>

		<dc:creator><![CDATA[Chris Hennick]]></dc:creator>
		<pubDate>Sun, 20 Jul 2014 15:50:21 +0000</pubDate>
		<guid isPermaLink="false">http://quoderat.megginson.com/?p=403#comment-9012</guid>

					<description><![CDATA[The only problem with this is that a clueless new employee might add a place with no subtype, or with more than one subtype.]]></description>
			<content:encoded><![CDATA[<p>The only problem with this is that a clueless new employee might add a place with no subtype, or with more than one subtype.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: John Cowan		</title>
		<link>https://quoderat.megginson.com/2010/09/25/sql-and-simple-polymorphism/#comment-3475</link>

		<dc:creator><![CDATA[John Cowan]]></dc:creator>
		<pubDate>Sun, 26 Sep 2010 17:49:50 +0000</pubDate>
		<guid isPermaLink="false">http://quoderat.megginson.com/?p=403#comment-3475</guid>

					<description><![CDATA[If your database unique IDs are just incrementing numbers, then yes.  If they are truly unique (e.g. UUIDs), then you can safely create the derived table entry before the base one.]]></description>
			<content:encoded><![CDATA[<p>If your database unique IDs are just incrementing numbers, then yes.  If they are truly unique (e.g. UUIDs), then you can safely create the derived table entry before the base one.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: stand		</title>
		<link>https://quoderat.megginson.com/2010/09/25/sql-and-simple-polymorphism/#comment-3474</link>

		<dc:creator><![CDATA[stand]]></dc:creator>
		<pubDate>Sun, 26 Sep 2010 05:47:08 +0000</pubDate>
		<guid isPermaLink="false">http://quoderat.megginson.com/?p=403#comment-3474</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://quoderat.megginson.com/2010/09/25/sql-and-simple-polymorphism/#comment-3473&quot;&gt;davidmegginson&lt;/a&gt;.

Yes, I am assuming that the id is an input parameter to the insert operations. You&#039;d have to use a GUID or some other id generating strategy.]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://quoderat.megginson.com/2010/09/25/sql-and-simple-polymorphism/#comment-3473">davidmegginson</a>.</p>
<p>Yes, I am assuming that the id is an input parameter to the insert operations. You&#8217;d have to use a GUID or some other id generating strategy.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: davidmegginson		</title>
		<link>https://quoderat.megginson.com/2010/09/25/sql-and-simple-polymorphism/#comment-3473</link>

		<dc:creator><![CDATA[davidmegginson]]></dc:creator>
		<pubDate>Sun, 26 Sep 2010 01:41:06 +0000</pubDate>
		<guid isPermaLink="false">http://quoderat.megginson.com/?p=403#comment-3473</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;https://quoderat.megginson.com/2010/09/25/sql-and-simple-polymorphism/#comment-3472&quot;&gt;stand&lt;/a&gt;.

stand: interesting idea, but if you want a unique id across all the subtypes, don&#039;t you have to assign it in the base table first?  Of course, if you already have your primary keys (e.g. employee numbers), then it&#039;s not an issue.]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="https://quoderat.megginson.com/2010/09/25/sql-and-simple-polymorphism/#comment-3472">stand</a>.</p>
<p>stand: interesting idea, but if you want a unique id across all the subtypes, don&#8217;t you have to assign it in the base table first?  Of course, if you already have your primary keys (e.g. employee numbers), then it&#8217;s not an issue.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: stand		</title>
		<link>https://quoderat.megginson.com/2010/09/25/sql-and-simple-polymorphism/#comment-3472</link>

		<dc:creator><![CDATA[stand]]></dc:creator>
		<pubDate>Sun, 26 Sep 2010 01:10:00 +0000</pubDate>
		<guid isPermaLink="false">http://quoderat.megginson.com/?p=403#comment-3472</guid>

					<description><![CDATA[Another trick a friend clued me into for inserts. Insert into the base table last. This gives you an effective transaction across all your base and derived tables inserts because if you insert into a derived table and then fail to insert to the base table, you just have an orphaned record in the derived table which won&#039;t show up in your normal queries. You can be assured that once the base table insert completes, you have a full record. Also, from a concurrency standpoint, your record doesn&#039;t show up to other reading threads until the base record is inserted and the full object can be populated.

For deletes, you remove the base table record first and then clean up the orphaned derived records.]]></description>
			<content:encoded><![CDATA[<p>Another trick a friend clued me into for inserts. Insert into the base table last. This gives you an effective transaction across all your base and derived tables inserts because if you insert into a derived table and then fail to insert to the base table, you just have an orphaned record in the derived table which won&#8217;t show up in your normal queries. You can be assured that once the base table insert completes, you have a full record. Also, from a concurrency standpoint, your record doesn&#8217;t show up to other reading threads until the base record is inserted and the full object can be populated.</p>
<p>For deletes, you remove the base table record first and then clean up the orphaned derived records.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Francis Avila		</title>
		<link>https://quoderat.megginson.com/2010/09/25/sql-and-simple-polymorphism/#comment-3471</link>

		<dc:creator><![CDATA[Francis Avila]]></dc:creator>
		<pubDate>Sat, 25 Sep 2010 23:17:58 +0000</pubDate>
		<guid isPermaLink="false">http://quoderat.megginson.com/?p=403#comment-3471</guid>

					<description><![CDATA[This technique is also called &quot;joined table inheritance&quot; and I&#039;ve used it to good effect in fairly large projects. Unfortunately it&#039;s very awkward to use with most ORM systems since it breaks the active record/active table pattern of one class per table and one row class per table row.

SQLAlchemy (python library) has &lt;a href=&quot;http://www.sqlalchemy.org/docs/orm/inheritance.html&quot; rel=&quot;nofollow&quot;&gt;native support for this pattern&lt;/a&gt; (and two other sql &quot;inheritance&quot; patterns) and makes working with them a dream. 

I constantly long for something of SQLAlchemy&#039;s expressiveness and power for php (which is 90% of my day job), but all the php ORMs (such as they are) appear to be active record patterned as well, vs the data mapper pattern SQLAlchemy uses where &quot;objects&quot; in your app are decoupled from tables, and you can establish flexible mappings between the two.]]></description>
			<content:encoded><![CDATA[<p>This technique is also called &#8220;joined table inheritance&#8221; and I&#8217;ve used it to good effect in fairly large projects. Unfortunately it&#8217;s very awkward to use with most ORM systems since it breaks the active record/active table pattern of one class per table and one row class per table row.</p>
<p>SQLAlchemy (python library) has <a href="http://www.sqlalchemy.org/docs/orm/inheritance.html" rel="nofollow">native support for this pattern</a> (and two other sql &#8220;inheritance&#8221; patterns) and makes working with them a dream. </p>
<p>I constantly long for something of SQLAlchemy&#8217;s expressiveness and power for php (which is 90% of my day job), but all the php ORMs (such as they are) appear to be active record patterned as well, vs the data mapper pattern SQLAlchemy uses where &#8220;objects&#8221; in your app are decoupled from tables, and you can establish flexible mappings between the two.</p>
]]></content:encoded>
		
			</item>
	</channel>
</rss>
