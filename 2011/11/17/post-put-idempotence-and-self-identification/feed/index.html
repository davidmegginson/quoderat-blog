<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: POST, PUT, idempotence, and self-identification	</title>
	<atom:link href="https://quoderat.megginson.com/2011/11/17/post-put-idempotence-and-self-identification/feed/" rel="self" type="application/rss+xml" />
	<link>https://quoderat.megginson.com/2011/11/17/post-put-idempotence-and-self-identification/</link>
	<description>Open information and technology.</description>
	<lastBuildDate>Tue, 16 Feb 2016 16:24:07 +0000</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
	<item>
		<title>
		By: your legacey club review		</title>
		<link>https://quoderat.megginson.com/2011/11/17/post-put-idempotence-and-self-identification/#comment-16017</link>

		<dc:creator><![CDATA[your legacey club review]]></dc:creator>
		<pubDate>Tue, 16 Feb 2016 16:24:07 +0000</pubDate>
		<guid isPermaLink="false">http://quoderat.megginson.com/?p=538#comment-16017</guid>

					<description><![CDATA[Hi, I would like to subscribe for this webpage to take most 
recent updates, thus where can i do it please help.]]></description>
			<content:encoded><![CDATA[<p>Hi, I would like to subscribe for this webpage to take most<br />
recent updates, thus where can i do it please help.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Gaius Gracchus		</title>
		<link>https://quoderat.megginson.com/2011/11/17/post-put-idempotence-and-self-identification/#comment-15601</link>

		<dc:creator><![CDATA[Gaius Gracchus]]></dc:creator>
		<pubDate>Thu, 10 Dec 2015 19:56:23 +0000</pubDate>
		<guid isPermaLink="false">http://quoderat.megginson.com/?p=538#comment-15601</guid>

					<description><![CDATA[This is odd:
--------------------------------------
POST http://example.org/actions/add-greeting
Hello!
PUT http://example.org/actions/add-greeting
Hello!
PUT http://example.org/actions/add-greeting
Hello!
--------------------------------------

Should you have used POST in the last two repetitions of this code?
Gaius G.]]></description>
			<content:encoded><![CDATA[<p>This is odd:<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;<br />
POST <a href="http://example.org/actions/add-greeting" rel="nofollow ugc">http://example.org/actions/add-greeting</a><br />
Hello!<br />
PUT <a href="http://example.org/actions/add-greeting" rel="nofollow ugc">http://example.org/actions/add-greeting</a><br />
Hello!<br />
PUT <a href="http://example.org/actions/add-greeting" rel="nofollow ugc">http://example.org/actions/add-greeting</a><br />
Hello!<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
<p>Should you have used POST in the last two repetitions of this code?<br />
Gaius G.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Don Park		</title>
		<link>https://quoderat.megginson.com/2011/11/17/post-put-idempotence-and-self-identification/#comment-3989</link>

		<dc:creator><![CDATA[Don Park]]></dc:creator>
		<pubDate>Mon, 05 Dec 2011 09:40:58 +0000</pubDate>
		<guid isPermaLink="false">http://quoderat.megginson.com/?p=538#comment-3989</guid>

					<description><![CDATA[I think it&#039;s like screwdrivers. I get them as a full set but most often used ones get misplaced and I have to got out to get another full set of screwdrivers. In all the webapps I&#039;ve written so far, I needed only one screwdriver: POST. Do I still want PUT in my toolbox? Absolutely. ;-)

Frankly, I am more concerned about impact of REST on usability these days because some of the extensive REST API&#039;s I&#039;ve seen, like SoundCloud&#039;s, made my eyes rollback like the way sound engineers&#039; desk do: whole lot of knobs, buttons, and sliders that all look alike. They screamed of beauty and order yet radiated total indifference to common needs.]]></description>
			<content:encoded><![CDATA[<p>I think it&#8217;s like screwdrivers. I get them as a full set but most often used ones get misplaced and I have to got out to get another full set of screwdrivers. In all the webapps I&#8217;ve written so far, I needed only one screwdriver: POST. Do I still want PUT in my toolbox? Absolutely. ðŸ˜‰</p>
<p>Frankly, I am more concerned about impact of REST on usability these days because some of the extensive REST API&#8217;s I&#8217;ve seen, like SoundCloud&#8217;s, made my eyes rollback like the way sound engineers&#8217; desk do: whole lot of knobs, buttons, and sliders that all look alike. They screamed of beauty and order yet radiated total indifference to common needs.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Francis Avila		</title>
		<link>https://quoderat.megginson.com/2011/11/17/post-put-idempotence-and-self-identification/#comment-3967</link>

		<dc:creator><![CDATA[Francis Avila]]></dc:creator>
		<pubDate>Fri, 18 Nov 2011 16:13:34 +0000</pubDate>
		<guid isPermaLink="false">http://quoderat.megginson.com/?p=538#comment-3967</guid>

					<description><![CDATA[This PUT problem becomes easier if the representation is self-documenting.

Your XML example of a country code doesn&#039;t actually contain any URLs, so the application needs to know how to construct them. Why not just include the URL in the XML? After all, this is how it&#039;s done in HTML and ATOM. This way the application doesn&#039;t need to know how to construct urls, only how to follow links. The application still needs to know enough about the resource representations to know where the links are, but it doesn&#039;t need to know how to construct links according to your (possibly changing) scheme.

We can take this further and have the state representation include links and methods for all operations that can be done on the resource and related resources. In your country example, there could be a link &quot;up&quot; to a page that lists all country urls, a notation that you can PUT to the present resource to replace it, and POST to another url to create. Again, browsing web pages is a good human analogy: nav bars, breadcrumbs, etc, are all to facilitate browsing. Just do for machine browsers what you would have done for a human browser. (The result will probably end up looking more like gopher, if you remember that.)

The problem is there&#039;s no standard &quot;language&quot; (other than maybe html A, LINK, and FORM elements) for expressing these relationships, so every representation has to roll its own and every application has to understand that particular representation&#039;s way of linking to resources.

Also, this only gets you to the point where an application can POST for create, and then, after the application knows the URL, it can PUT for updates. Maybe it will always be too much of a burden to require PUT for create.

Web Application Description Language (WADL) is trying to address this space for RESTful apis in the same way that WSDL tried to do for more RPC-like protocols. I definitely think there&#039;s a place for things like this (and it may have mechanisms to enable reliable &quot;PUT-create&quot; operations), but solutions like this are heavy and still don&#039;t put the resource links *inside* the representation itself.]]></description>
			<content:encoded><![CDATA[<p>This PUT problem becomes easier if the representation is self-documenting.</p>
<p>Your XML example of a country code doesn&#8217;t actually contain any URLs, so the application needs to know how to construct them. Why not just include the URL in the XML? After all, this is how it&#8217;s done in HTML and ATOM. This way the application doesn&#8217;t need to know how to construct urls, only how to follow links. The application still needs to know enough about the resource representations to know where the links are, but it doesn&#8217;t need to know how to construct links according to your (possibly changing) scheme.</p>
<p>We can take this further and have the state representation include links and methods for all operations that can be done on the resource and related resources. In your country example, there could be a link &#8220;up&#8221; to a page that lists all country urls, a notation that you can PUT to the present resource to replace it, and POST to another url to create. Again, browsing web pages is a good human analogy: nav bars, breadcrumbs, etc, are all to facilitate browsing. Just do for machine browsers what you would have done for a human browser. (The result will probably end up looking more like gopher, if you remember that.)</p>
<p>The problem is there&#8217;s no standard &#8220;language&#8221; (other than maybe html A, LINK, and FORM elements) for expressing these relationships, so every representation has to roll its own and every application has to understand that particular representation&#8217;s way of linking to resources.</p>
<p>Also, this only gets you to the point where an application can POST for create, and then, after the application knows the URL, it can PUT for updates. Maybe it will always be too much of a burden to require PUT for create.</p>
<p>Web Application Description Language (WADL) is trying to address this space for RESTful apis in the same way that WSDL tried to do for more RPC-like protocols. I definitely think there&#8217;s a place for things like this (and it may have mechanisms to enable reliable &#8220;PUT-create&#8221; operations), but solutions like this are heavy and still don&#8217;t put the resource links *inside* the representation itself.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Ed Davies		</title>
		<link>https://quoderat.megginson.com/2011/11/17/post-put-idempotence-and-self-identification/#comment-3966</link>

		<dc:creator><![CDATA[Ed Davies]]></dc:creator>
		<pubDate>Fri, 18 Nov 2011 11:59:08 +0000</pubDate>
		<guid isPermaLink="false">http://quoderat.megginson.com/?p=538#comment-3966</guid>

					<description><![CDATA[The problem is not subtle differences. The problem is that people just don&#039;t care whether they actually implement HTTP or only something which uses port 80 and superficially looks a bit like HTTP:

http://wiki.openstreetmap.org/wiki/Talk:API_v0.6#Overloading_of_PUT_method

----

Kurt Cagel: &quot;Yet if you assume idempotency (and hence non-destructive PUTs and revisional content)...&quot;

I think you misunderstand the word &quot;idempotency&quot;. From http://en.wikipedia.org/wiki/Idempotence

&quot;Idempotence (...) is the property of certain operations in mathematics and computer science, that they can be applied multiple times without changing the result beyond the initial application.&quot;

PUT can be destructive yet idempotent. The point is that if you do the PUT two or more times it has the same effect as only doing it once. If a system creates new revisions (and mints new revision URIs) for each PUT operation even if the representation put is the same then the operation is not idempotent. If it simply overwrites the resource with the given URI then it may well be.]]></description>
			<content:encoded><![CDATA[<p>The problem is not subtle differences. The problem is that people just don&#8217;t care whether they actually implement HTTP or only something which uses port 80 and superficially looks a bit like HTTP:</p>
<p><a href="http://wiki.openstreetmap.org/wiki/Talk:API_v0.6#Overloading_of_PUT_method" rel="nofollow ugc">http://wiki.openstreetmap.org/wiki/Talk:API_v0.6#Overloading_of_PUT_method</a></p>
<p>&#8212;-</p>
<p>Kurt Cagel: &#8220;Yet if you assume idempotency (and hence non-destructive PUTs and revisional content)&#8230;&#8221;</p>
<p>I think you misunderstand the word &#8220;idempotency&#8221;. From <a href="http://en.wikipedia.org/wiki/Idempotence" rel="nofollow ugc">http://en.wikipedia.org/wiki/Idempotence</a></p>
<p>&#8220;Idempotence (&#8230;) is the property of certain operations in mathematics and computer science, that they can be applied multiple times without changing the result beyond the initial application.&#8221;</p>
<p>PUT can be destructive yet idempotent. The point is that if you do the PUT two or more times it has the same effect as only doing it once. If a system creates new revisions (and mints new revision URIs) for each PUT operation even if the representation put is the same then the operation is not idempotent. If it simply overwrites the resource with the given URI then it may well be.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Kurt Cagle		</title>
		<link>https://quoderat.megginson.com/2011/11/17/post-put-idempotence-and-self-identification/#comment-3965</link>

		<dc:creator><![CDATA[Kurt Cagle]]></dc:creator>
		<pubDate>Fri, 18 Nov 2011 03:44:47 +0000</pubDate>
		<guid isPermaLink="false">http://quoderat.megginson.com/?p=538#comment-3965</guid>

					<description><![CDATA[David,

The distinction actually is more subtle. Assume for the moment that you know nothing about the back end state or representation of the object in question - that is to say, there is a transformation that converts your POSTed or PUT document into the internal state of the server. If you assume that you have a purely idempotent system (one where a resource is never destroyed) then PUT becomes a mechanism for handling versioning. I&#039;ve actually been working on such a system for a publishing client, in which POST effectively creates a new &quot;resource&quot; while PUT updates that resource, but in the back end, the POST actually creates two &quot;documents&quot; - a resource &quot;proxy&quot; and the first or base revision of that document. The PUT, on the other hand, will just create a revision of that original document and save it, with the revision having a different identifier than that version version of that document. 

 When you retrieve that document, you are getting the latest revision of that document, but the system itself never destroys previous revisions. What&#039;s more, the same system can store within each revision its revision chain (via URL pointers stored in an envelope holding the document), meaning that the base object will have an auditable history. This implies that in such an environment, even PUT is non-destructive.

The processing pipelines in this case are really the key to this. A lot of (perhaps most) people have some strong misconceptions about REST. The first is that if you use GET and POST, you are engaging in REST, yet the vast majority of such calls are in fact RPCs (especially POST) - you are passing a bundle of parametric content along with an imperative expressed through either the URL or the payload, and you get back other content as a consequence. 

The second expression of REST is that it is in fact nothing but CRUD, that you save or load resources to a database through a URI. While this is technically more RESTful, it does not take advantage of the fact that the internal and external representations of a resource do not necessarily have to match - so long as the external representation can be transformed from an internal representation and vice versa (albeit with no requirements that the results coming in or going out have to be the same representations) you are still doing RESTful operations.  

Yet if you assume idempotency (and hence non-destructive PUTs and revisional content) then what emerges is a truly &quot;stateless&quot;, purely declarative system, because you can, in theory, pass in a time parameter and get back the state of that resource at that time for any time in a resource&#039;s history.

This has profound implications for semantic systems. One of the biggest challenges that linked data systems face is that in a destructive REStful system, RDF triples can only describe relationships relative to the current state of the triple store system - even if such triples are themselves never destroyed. On the other hand, in an IDEMPOTENT PUT system, the relationships that resources have (assuming that the predicate of such a relationship is also defined in such a manner) can be rolled forward or back over time. As a consequence, such a triple store becomes a time machine that evinces the relational descriptions between its resources based upon the timestamp of the query. 

I&#039;m aware that there are data modeling systems that do this already, but I think as the relationships between resources, REST and RDF become more fully understood (and I do believe there is a DEEP connection between these) and as hardware and software systems advance to the point where idempotent PUT becomes the norm rather than the exception, I believe that we&#039;ll see some very interesting developments in this space.]]></description>
			<content:encoded><![CDATA[<p>David,</p>
<p>The distinction actually is more subtle. Assume for the moment that you know nothing about the back end state or representation of the object in question &#8211; that is to say, there is a transformation that converts your POSTed or PUT document into the internal state of the server. If you assume that you have a purely idempotent system (one where a resource is never destroyed) then PUT becomes a mechanism for handling versioning. I&#8217;ve actually been working on such a system for a publishing client, in which POST effectively creates a new &#8220;resource&#8221; while PUT updates that resource, but in the back end, the POST actually creates two &#8220;documents&#8221; &#8211; a resource &#8220;proxy&#8221; and the first or base revision of that document. The PUT, on the other hand, will just create a revision of that original document and save it, with the revision having a different identifier than that version version of that document. </p>
<p> When you retrieve that document, you are getting the latest revision of that document, but the system itself never destroys previous revisions. What&#8217;s more, the same system can store within each revision its revision chain (via URL pointers stored in an envelope holding the document), meaning that the base object will have an auditable history. This implies that in such an environment, even PUT is non-destructive.</p>
<p>The processing pipelines in this case are really the key to this. A lot of (perhaps most) people have some strong misconceptions about REST. The first is that if you use GET and POST, you are engaging in REST, yet the vast majority of such calls are in fact RPCs (especially POST) &#8211; you are passing a bundle of parametric content along with an imperative expressed through either the URL or the payload, and you get back other content as a consequence. </p>
<p>The second expression of REST is that it is in fact nothing but CRUD, that you save or load resources to a database through a URI. While this is technically more RESTful, it does not take advantage of the fact that the internal and external representations of a resource do not necessarily have to match &#8211; so long as the external representation can be transformed from an internal representation and vice versa (albeit with no requirements that the results coming in or going out have to be the same representations) you are still doing RESTful operations.  </p>
<p>Yet if you assume idempotency (and hence non-destructive PUTs and revisional content) then what emerges is a truly &#8220;stateless&#8221;, purely declarative system, because you can, in theory, pass in a time parameter and get back the state of that resource at that time for any time in a resource&#8217;s history.</p>
<p>This has profound implications for semantic systems. One of the biggest challenges that linked data systems face is that in a destructive REStful system, RDF triples can only describe relationships relative to the current state of the triple store system &#8211; even if such triples are themselves never destroyed. On the other hand, in an IDEMPOTENT PUT system, the relationships that resources have (assuming that the predicate of such a relationship is also defined in such a manner) can be rolled forward or back over time. As a consequence, such a triple store becomes a time machine that evinces the relational descriptions between its resources based upon the timestamp of the query. </p>
<p>I&#8217;m aware that there are data modeling systems that do this already, but I think as the relationships between resources, REST and RDF become more fully understood (and I do believe there is a DEEP connection between these) and as hardware and software systems advance to the point where idempotent PUT becomes the norm rather than the exception, I believe that we&#8217;ll see some very interesting developments in this space.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Chuck		</title>
		<link>https://quoderat.megginson.com/2011/11/17/post-put-idempotence-and-self-identification/#comment-3964</link>

		<dc:creator><![CDATA[Chuck]]></dc:creator>
		<pubDate>Fri, 18 Nov 2011 00:27:09 +0000</pubDate>
		<guid isPermaLink="false">http://quoderat.megginson.com/?p=538#comment-3964</guid>

					<description><![CDATA[If you trust clients to put the right representations at the right URLs, then PUT might be good; if you dont, then maybe POST is better.  If your URI structure is static and clients can easily construct the right URL, then PUT might be good.  If it is important that your clients be able to simply try again when they experience a network error, PUT might work better for you.  If your application can detect duplicate POST requests based on the content and do the right thing, then maybe POST is just fine.  If your legacy app is the only thing using the service and it&#039;s extra work to make it add the ISO code to the end of the URL for a PUT, then use POST.  If some of your clients dont support PUT, then maybe POST is better.]]></description>
			<content:encoded><![CDATA[<p>If you trust clients to put the right representations at the right URLs, then PUT might be good; if you dont, then maybe POST is better.  If your URI structure is static and clients can easily construct the right URL, then PUT might be good.  If it is important that your clients be able to simply try again when they experience a network error, PUT might work better for you.  If your application can detect duplicate POST requests based on the content and do the right thing, then maybe POST is just fine.  If your legacy app is the only thing using the service and it&#8217;s extra work to make it add the ISO code to the end of the URL for a PUT, then use POST.  If some of your clients dont support PUT, then maybe POST is better.</p>
]]></content:encoded>
		
			</item>
	</channel>
</rss>
